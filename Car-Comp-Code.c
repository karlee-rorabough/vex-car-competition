#pragma config(Sensor, dgtl1,  RedBoi,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  GreenBoi,       sensorLEDtoVCC)
#pragma config(Motor,  port2,           RickFL,        tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ChrisFR,       tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           HenryBR,       tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port5,           GriffinBL,     tmotorVex269_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int currentLineSensorValue = 0;

int getLineTrackerResult(int lineTrackerPort) {
	const int lowThreshold = 1000;
	const int highThreshold = 2000;
	int value = SensorValue[lineTrackerPort];
	if (value < lowThreshold) {
		return -1;
	} else if (value > highThreshold) {
		return +1;
	} else {
	  return 0;
	}
}

task main()
{
	SensorValue[RedBoi] = false;
	SensorValue[GreenBoi] = true;
	int speed = 127;
	int frx = +1;
	int flx = +1;
	int brx = +1;
	int blx = +1;
	bool autonomous = false;
	while(true) {

		// Logic for switching between modes //
		if (vexRT[Btn7U] == 1) {
			autonomous = false;
			SensorValue[RedBoi] = false;
			SensorValue[GreenBoi] = true;
		}
		if (vexRT[Btn7L] == 1) {
			autonomous = true;
			SensorValue[RedBoi] = true;
			SensorValue[GreenBoi] = false;
		}


		if (autonomous == false){
			// This is teleop //
			motor[ChrisFR] = vexRT[Ch2];
			motor[HenryBR]  = vexRT[Ch2];
			motor[RickFL] = vexRT[Ch3];
			motor[GriffinBL]  = vexRT[Ch3];
			} else {
			// Autonomous: Drive forward //
			motor[ChrisFR] = speed * frx;
			motor[GriffinBL] = speed * brx;
			motor[HenryBR] = speed * blx;
			motor[RickFL] = speed * flx;
		}
	}
}
